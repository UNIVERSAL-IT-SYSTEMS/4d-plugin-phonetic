/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Phonetic
 #	author : miyako
 #	2016/06/21
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

#pragma mark -

bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void OnStartup()
{
#if VERSIONWIN
	setlocale(LC_ALL, "Japanese");
	CoInitialize(NULL);
#endif
}

void OnCloseProcess()
{
	if(IsProcessOnExit())
	{
#if VERSIONWIN
		CoUninitialize();
#endif
	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
			
		case kCloseProcess :
			OnCloseProcess();
			break;
// --- Phonetic

		case 1 :
			PHONETIC(pResult, pParams);
			break;

	}
}

#pragma mark -

// ----------------------------------- Phonetic -----------------------------------

#if VERSIONWIN
static bool EnumCandidatesCallback(int index, int count, const wchar_t *candidate, void *param)
{
	ARRAY_TEXT *target = (ARRAY_TEXT *)param;
	target->appendUTF16String((const PA_Unichar *) candidate);
	
	return true;
}
#else
#if !__LP64__
LAEnvironmentRef LAEnvironmentGetJapaneseMorphemeAnalysis()
{
	LAEnvironmentRef r = NULL;
	
	UInt32 actualCount;
	LAGetEnvironmentList(0, &actualCount, NULL);
	std::vector<uint8_t> environmentBuf(actualCount * (sizeof(Str63)));
	LAEnvironmentRef *environmentList = (LAEnvironmentRef *)&environmentBuf[0];
	LAGetEnvironmentList(actualCount, &actualCount, environmentList);
	
	for (unsigned int i = 0; i < actualCount; ++i)
	{
		Str63 environmentName;
		LAGetEnvironmentName(environmentList[i], environmentName);
		NSString *name = (NSString *)CFStringCreateWithPascalString(kCFAllocatorDefault, environmentName, kCFStringEncodingMacRoman);
		if(name)
		{
			if([name isEqualToString:@"JapaneseMorphemeAnalysis"])	r = environmentList[i];
			
			[name release];
		}

	}
	
	return r;
}
#endif
#endif

void PHONETIC(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	ARRAY_TEXT Param2;
	ARRAY_TEXT Param3;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.setSize(1);
	Param3.setSize(1);
	
	if(Param1.getUTF16Length())
	{
#if VERSIONWIN
		TsfReconverter	reconverter;
		if(reconverter.IsOpened())
		{
			reconverter.EnumCandidates((const wchar_t *)Param1.getUTF16StringPtr(), &EnumCandidatesCallback, &Param3);
			Param2.setSize(Param3.getSize());
		}
#else
#if !__LP64__
		/* deprecated carbon api */
		LAEnvironmentRef environment = LAEnvironmentGetJapaneseMorphemeAnalysis();
		if(environment)
		{
			LAContextRef context;
			LAOpenAnalysisContext (environment, &context);
			LAMorphemeBundle morphemeBundle;
			ItemCount itemCount = 100;
			if(!LAMorphemeAnalysis (context, Param1.getUTF16StringPtr(), Param1.getUTF16Length(), NULL, NULL, itemCount, &morphemeBundle))
			{
//				AEDesc paths;
				AEDesc nodes;
//				AEGetParamDesc(&morphemeBundle, keyAELAMorphemePath, typeAEList, &paths);
				AEGetParamDesc(&morphemeBundle, keyAELAMorpheme, typeAEList, &nodes);
//				long countPaths;
				long countNodes;
//				AECountItems(&paths, &countPaths);
				AECountItems(&nodes, &countNodes);
				
					for (int n = 1; n <= countNodes; ++n)
					{
						AEDesc node;
						AEGetNthDesc(&nodes, n, typeAERecord, NULL, &node);
						
						AEDesc range;
						AEGetParamDesc(&node, keyAEMorphemeTextRange, typeAEMorphemeTextRange, &range);
						MorphemeTextRange r;
						AEGetDescData(&range, &r, sizeof(MorphemeTextRange));
						unsigned int len = EndianU32_BtoL(r.length);
						unsigned int off = EndianU32_BtoL(r.sourceOffset);
						//the source string for this range
						NSString *convertedString = Param1.copyUTF16String();
						NSString *convertedStringRange = [[NSString alloc]initWithString:[convertedString substringWithRange:NSMakeRange(off, len)]];
						[convertedString release];
						
						AEDesc homographs;
						AEGetParamDesc(&node, keyAELAHomograph, typeAEList, &homographs);
						long countHomographs;
						AECountItems(&homographs, &countHomographs);
						if(countHomographs)
						{
							//array of phonetics for this range
							for (int h = 1; h <= countHomographs; ++h)
							{
								AEDesc homographNode;
								AEGetNthDesc(&homographs, h, typeAERecord, NULL, &homographNode);
								AEDesc homograph;
								AEGetParamDesc(&homographNode, keyAEText, typeUnicodeText, &homograph);
								size_t bufSize = AEGetDescDataSize(&homograph);
								std::vector<uint8_t> buf(bufSize + sizeof(PA_Unichar));
								AEGetDescData(&homograph, &buf[0], bufSize);
								Param3.appendUTF16String((const PA_Unichar *)&buf[0]);
								Param2.appendUTF16String(convertedStringRange);
							}
							
						}
						[convertedStringRange release];
					}
				LACloseAnalysisContext(context);
			}
			
		}
#endif
#endif
	}
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
}

